# Прототипы и классы

Весь JS работает на прототипах. Рассмотрим пример:

```ts
const user = {
  name: 'Kirill',
};

console.log(user.name); // "Kirill"
console.log(user.toString()); // "[object Object]"
```

Здесь мы создаем объект `user`. В объекте мы явно указали поле `name` и можем с ним работать. Но откуда взялся метод `toString()`? У нашего объекта этого поля нет, но оно есть у объекта `Object.prototype` (что такое `Object` разберем позже).

На самом деле, когда мы создаем какой-то объект, в JS созданному объекту добавляется ссылка на некий прототип. **Прототип** - это просто объект со своим набором полей и методов, который используется для их наследования. Когда мы пытаемся обратиться к полю или методу, которого нет у нашего объекта, JS начинает искать его в прототипе нашего объекта.

Получить прототип объекта можно с помощью метода `Object.getPrototypeOf`:

```ts
const user = {
  name: 'Kirill';
};

const prototype = Object.getPrototypeOf(user);
console.log(prototype === Object.prototype); // true
```

Если вывести в консоль `Object.prototype`, можно увидеть его поля и методы.

Прототипы - это всегда про цепочки. Например, можно получить и прототип объекта `Object.prototype` - это будет `null`, т.е. конец цепочки:

![](assets/proto1.png)

Если мы попытаемся обратиться к какому-нибудь методу, алгоритм будет выглядеть примерно так:
```
Ищем метод у объекта user.
Метод есть? Вызываем его. Метода нет? Ищем дальше.
Ищем метод у Object.prototype.
Метод есть? Вызываем его. Метода нет? Ищем дальше.
У null методов быть не может. Выбрасываем ошибку.
```

С обращением к полям объекта история такая же. С той лишь разницей, что поле просто вернет `undefined`.

Этот механизм называется **прототипным наследованием**. Более интересный пример с массивами и функциями:

```ts
const arr = [];
console.log(Object.getPrototypeOf(arr)); // Array.prototype
console.log(Object.getPrototypeOf(Array.prototype)); // Object.prototype

function func() {};
console.log(Object.getPrototypeOf(func)); // Function.prototype
console.log(Object.getPrototypeOf(Function.prototype)); // Object.prototype

console.log(Object.getPrototypeOf(Array.prototype) === Object.getPrototypeOf(Function.prototype)); // true
```

![](assets/proto2.png)

Как следствие из всего вышесказанного, мы можем определить поля и методы у наших объектов типа `toString()`, но с той логикой которой захотим. Обновим пример из начала урока:

```ts
const user = {
  name: 'Kirill',
  toString() {
    return `User: ${this.name}`;
  }
};

console.log(user.name); // "Kirill"
console.log(user.toString()); // "User: Kirill"
```

Теперь мы обращаемся к `toString()` объекта `user`, а не `Object.prototype`. При большом желании, мы можем обновить свойства и самого прототипа:

```ts
Object.prototype.toString = () => {
  return 'I am object!';
}

const obj = {};
console.log(obj.toString()); // "I am object!";
```

Но делать этого КРАЙНЕ не рекомендую в 99% случаев. Менять базовую логику (как и добавлять новые свойства) может привести к непредсказуемому поведению.

TODO setPrototypeOf()
TODO синтаксис классов
TODO классовое наследование