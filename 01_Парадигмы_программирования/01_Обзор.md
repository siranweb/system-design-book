# Обзор парадигм программирования

**Парадигма программирования** - это некий подход к решению проблем программирования. Следуя какой-то парадигме, мы используем её идеи и практики для реализации программы. Сегодня много языков являются **мультипарадигменными**, в частности JavaScript/TypeScript.

Парадигмы делятся на [огромное кол-во групп и вариаций](https://ru.wikipedia.org/wiki/%D0%9F%D0%B0%D1%80%D0%B0%D0%B4%D0%B8%D0%B3%D0%BC%D0%B0_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F), но в рамках курса мы будем придерживаться ООП-стиля.

## Императивный и декларативный стиль

Прежде, чем идти дальше, стоит рассмотреть императивный и декларативный стили.
**Императивный стиль** описывает КАК работает код. Он крайне прямолинейный:

```ts
function hasEvenGreaterThanTen(numbers: number[]): boolean {
    for (let i = 0; i < numbers.length; i++) {
        const num = numbers[i];
        if (num > 10 && num % 2 === 0) {
            return true;
        }
    }
    return false;
}

console.log(hasEvenGreaterThanTen([1, 3, 7, 12, 9])); // true
console.log(hasEvenGreaterThanTen([1, 3, 5, 7, 9]));  // false
```

Выше представлен код, проверяющий есть ли в массиве четные числа больше 10. Он работает, и его можно понять. Однако, чем сложнее задача, тем труднее будет разобраться в происходящем.

Чтобы упростить пример выше, можно воспользоваться **декларативным стилем**. Этот стиль описывает ЧТО код делает. Происходит это с помощью вынесения отдельной логики в функции:
```ts
function isEven(num: number): boolean {
	return num % 2 === 0;
}

function isGreaterThanTen(num: number): boolean {
	return num > 10;
}

function hasEvenGreaterThanTen(numbers: number[]): boolean {
    for (let i = 0; i < numbers.length; i++) {
        const num = numbers[i];
        if (isGreaterThanTen(num) && isEven(num)) { // !
            return true;
        }
    }
    return false;
}

console.log(hasEvenGreaterThanTen([1, 3, 7, 12, 9])); // true
console.log(hasEvenGreaterThanTen([1, 3, 5, 7, 9]));  // false
```

Этот код легче поддается понимаю благодаря функциям. Помимо вынесения части логики, они документируют ЧТО они делают. Код можно упростить еще сильнее, избавившись от цикла и используя метод `some`:

```ts
function isEven(num: number): boolean {
	return num % 2 === 0;
}

function isGreaterThanTen(num: number): boolean {
	return num > 10;
}

function hasEvenGreaterThanTen(numbers: number[]): boolean {
	return numbers.some(num => isGreaterThanTen(num) && isEven(num)); // !
}

console.log(hasEvenGreaterThanTen([1, 3, 7, 12, 9])); // true
console.log(hasEvenGreaterThanTen([1, 3, 5, 7, 9]));  // false
```

Мы избавились от императивного цикла, описывающий КАК он работает. Метод `some` является декларативным, т.к. он говорит ЧТО делает - а именно проходит по массиву пока условие не будет `true`. Согласитесь, понять такой код уже намного проще, чем первоначальный вариант.

 Однако есть нюанс. Важно понимать - в основе любой декларативной функции лежит именно императивный подход. Функция `isEven` сама по себе декларативна, но конструкция `num % 2 === 0` - императивна. Хотя эта конструкция крайне проста и комментируется названием функции, где она находится.

Наша задача как инженеров - писать простой, понятный и поддерживаемый код. На практике всегда стоит стремиться к декларативности.
## Парадигмы

Стоит рассмотреть хотя бы три известные парадигмы. Разберем их подходы на примере простой задачи:

```
Дан массив чисел [1, 2, 3, 4, 5, 6]. Необходимо отфильтровать четные числа, возвести каждое в квадрат и посчитать их сумму.
```
### Процедурное программирование

Это подход, при котором последовательные выполняемые операции могут быть собраны в функции (подпрограммы). Суть подхода в разбиении задачи на шаги для их последовательного выполнения.

```ts
// Внешнее состояние
let result: number = 0;

// Вывод результата
function printResult(): void {
    console.log("Результат:", result);
}

// Вычисление
function calculate(numbers: number[]): void {
    let sum = 0;

    for (let i = 0; i < numbers.length; i++) {
        const num = numbers[i];
        if (num % 2 === 0) {
            sum += num * num;
        }
    }
    
    result = sum;
}


function calculateAndPrintSumSquaresOfEvens(numbers: number[]): void {
    calculate(numbers);
    printResult();
}

const arr = [1, 2, 3, 4, 5, 6];
calculateAndPrintSumSquaresOfEvens(arr); // "Результат: 56"
```

Особенности кода выше:
- Логика разбита на процедуры `calculate` и `printResult`. Процедура `calculateAndPrintSumSquaresOfEvens` агрегирует выполнение.
- Процедуры не возвращают какое-то значение - вместо этого они работают с внешним состоянием. Это порождает побочные эффекты, из-за чего поведение функций менее очевидно.

Процедурное программирование само по себе простое. Но за это позже придется расплачиваться большими кодовыми базами, полные запутанного поведения.

### Функциональное программирование (ФП)
В отличии от процедурного программирования, ФП вкладывает в функции математический смысл. Функции работают только с входными данными и возвращают результат выполнения. Никаких внешних состояний тут быть не может.

```ts
const sum = (numbers: number[]): number =>
    numbers
        .filter(n => n % 2 === 0)
        .map(n => n * n)
        .reduce((acc, n) => acc + n, 0);
        
console.log(sum([1, 2, 3, 4, 5, 6])); // 56
```

Особенности кода выше:
- Никаких внешних состояний. Все функции вызываются друг за другом списком, и передают свой результат выполнения как входные данные в следующую функцию.
- Т.к. нет внешнего состояния, побочные эффекты тоже отсутствуют.

Хорошие функции в ФП лаконичны и легко читаемы, т.к. они сами по себе декларативны. Хотя сами по себе они работают несколько медленнее (при каждом выполнении функций `filter`, `map` и `reduce` мы создаем новые массивы), на практике чистота и ясность кода играют куда бОльшую роль. По крайней мере пока мы не спускаемся в системное программирование.

В настоящее время в коммерческих проектах ФП не пользуется особой популярностью. Предпочтение отдается ООП.

### Объектно-ориентированное программирование (ООП)
Ключевой особенностью ООП являются объекты - все крутится вокруг них. Объекты хранят внутри себя состояние и поведение, а также управляют доступом к ним.
```ts
class NumberProcessor {
    private numbers: number[];

    constructor(numbers: number[]) {
        this.numbers = numbers;
    }

    public sumSquaresOfEvens(): number {
        return this.numbers
            .filter(n => n % 2 === 0)
            .map(n => n * n)
            .reduce((acc, n) => acc + n, 0);
    }
}

const processor = new NumberProcessor([1, 2, 3, 4, 5, 6]);
console.log(processor.sumSquaresOfEvens()); // 56
```

Особенности кода выше:
- Объект `processor` хранит состояние `numbers` внутри, а модификатор `private` не даст обратиться к нему извне. Это означает, что элементы извне не смогут обратиться к внутреннему состоянию и повлиять на него. Все управление проходит строго через метод объекта `sumSquaresOfEvens`. При необходимости, объект можно расширить другими методами для управления этого состоянием.
- Как в случае с процедурным стилем, наши методы могут менять это состояние, и это может привести к неочевидной логике. Но, в отличии от процедурного программирования, мы рассматриваем состояние и методы для управления им как единое целое. Класс объекта `NumberProcessor` дает понять, что он служит для обработки чисел, а метод `sumSquaresOfEvens` - что он считает сумму квадратов четных чисел. Это удачный пример декларативного подхода.
## Использование нескольких парадигм

Как описывалось раннее, парадигмы - это про использование идей и практик. Никто не запрещает их совмещать. Напротив, чаще всего именно такой подход и будет использоваться.

Это можно было заметить и в примерах выше. Например, метод объекта реализован с использованием ФП благодаря вызовам последовательных методов массива. Но метод мог быть реализован и так:

```ts
public sumSquaresOfEvens(): number {
	let sum = 0;
	for (let i = 0; i < numbers.length; i++) {
        const num = numbers[i];
        if (num % 2 === 0) {
            sum += num * num;
        }
    }
    return sum;
}
```

Копая дальше - методы `filter`, `map` и `reduce` принадлежат объекту (массиву) `array`, хотя само по себе их выполнение не зависит от какого-то состояния (не считая сам массив). Это пример смешивания ООП и ФП, где берутся лучшие практики от обоих подходов.

Если бы мы хранили какой-то результат в состоянии, наш класс выглядит бы примерно так:

```ts
class NumberProcessor {
    private numbers: number[];
    private result: number = 0;

    constructor(numbers: number[]) {
        this.numbers = numbers;
    }

    public sumSquaresOfEvens(): void {
        this.result = this.numbers
            .filter(n => n % 2 === 0)
            .map(n => n * n)
            .reduce((acc, n) => acc + n, 0);
    }
    
    public getResult(): number {
	    return this.result;
    }
}

const processor = new NumberProcessor([1, 2, 3, 4, 5, 6]);
processor.sumSquaresOfEvens();
console.log(processor.getResult()); // 56
```

В этом случае, наш метод `sumSquaresOfEvens` изменяет состояние, а метод `getResult` возвращает его, что характерно для процедурного программирования. В этом примере это выглядит натянуто, но подобный прием может использоваться в более сложных ситуациях, о чем будет рассказано в последующих главах.

С этого момента мы будем придерживаться ООП стиля, совмещая подходы других стилей.